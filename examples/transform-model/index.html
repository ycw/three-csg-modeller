<!doctype html>

<head>
    <meta charset="utf8">
    <title>Transform Model</title>
    <link rel="icon" href="#">
    <link rel="stylesheet" href="../index.css">
</head>

<body>
    <script type="module">
        import * as THREE from "https://unpkg.com/three@0.121.1/build/three.module.js"
        import { OrbitControls } from "https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls"
        import Modeller from "../../src/index.js";

        // ----
        // Boot
        // ----

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, 2, .1, 100);
        const controls = new OrbitControls(camera, renderer.domElement);
        window.addEventListener('resize', () => {
            const { clientWidth, clientHeight } = renderer.domElement;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(clientWidth, clientHeight, false);
            camera.aspect = clientWidth / clientHeight;
            camera.updateProjectionMatrix();
        });
        document.body.prepend(renderer.domElement);
        window.dispatchEvent(new Event('resize'));
        renderer.setAnimationLoop(() => {
            renderer.render(scene, camera);
            controls.update();
        });

        // ----
        // Main
        // ----

        camera.position.set(2, 1, 2);
        controls.autoRotate = true;
        scene.add(new THREE.HemisphereLight("white", "powderblue"));

        const modeller = new Modeller(THREE);
        const mat = new THREE.MeshLambertMaterial();

        let bodyModel;
        {
            const mesh = new THREE.Mesh(new THREE.CylinderBufferGeometry(0.5, 0.5, 1, 64, 1), mat);
            const outer = modeller.model(mesh);

            // Mesh-level transformation only affects subsequent model creation.
            mesh.scale.set(0.4, 1.0, 0.4);
            const inner = modeller.model(mesh);
            
            bodyModel = outer.subtract(inner);
        }
        
        let paperModel;
        { 
            const mesh = new THREE.Mesh(new THREE.CylinderBufferGeometry(0.5, 0.5, 1, 64, 1), mat);
            const outer = modeller.model(mesh);
 
            mesh.scale.set(0.97, 1.0, 0.97);
            const inner = modeller.model(mesh);

            const cutterMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(10, 1, 1), mat);
            cutterMesh.position.set(0, 0, 0.4);
            const cutter = modeller.model(cutterMesh);

            // Transform a model by a matrix. ( `model.applyMatrix4` returns a new Model )
            const matrix = new THREE.Matrix4().makeTranslation(0.1, 0, -0.025);
            paperModel = outer.subtract(inner).subtract(cutter).applyMatrix4(matrix);
        }

        scene.add(bodyModel.union(paperModel).build());
    </script>
</body>