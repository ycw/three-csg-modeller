{"version":3,"file":"lib.esm.js","sources":["../lib/csg.js","../src/Model.js","../src/index.js"],"sourcesContent":["// Constructive Solid Geometry (CSG) is a modeling technique that uses Boolean\n// operations like union and intersection to combine 3D solids. This library\n// implements CSG operations on meshes elegantly and concisely using BSP trees,\n// and is meant to serve as an easily understandable implementation of the\n// algorithm. All edge cases involving overlapping coplanar polygons in both\n// solids are correctly handled.\n// \n// Example usage:\n// \n//     var cube = CSG.cube();\n//     var sphere = CSG.sphere({ radius: 1.3 });\n//     var polygons = cube.subtract(sphere).toPolygons();\n// \n// ## Implementation Details\n// \n// All CSG operations are implemented in terms of two functions, `clipTo()` and\n// `invert()`, which remove parts of a BSP tree inside another BSP tree and swap\n// solid and empty space, respectively. To find the union of `a` and `b`, we\n// want to remove everything in `a` inside `b` and everything in `b` inside `a`,\n// then combine polygons from `a` and `b` into one solid:\n// \n//     a.clipTo(b);\n//     b.clipTo(a);\n//     a.build(b.allPolygons());\n// \n// The only tricky part is handling overlapping coplanar polygons in both trees.\n// The code above keeps both copies, but we need to keep them in one tree and\n// remove them in the other tree. To remove them from `b` we can clip the\n// inverse of `b` against `a`. The code for union now looks like this:\n// \n//     a.clipTo(b);\n//     b.clipTo(a);\n//     b.invert();\n//     b.clipTo(a);\n//     b.invert();\n//     a.build(b.allPolygons());\n// \n// Subtraction and intersection naturally follow from set operations. If\n// union is `A | B`, subtraction is `A - B = ~(~A | B)` and intersection is\n// `A & B = ~(~A | ~B)` where `~` is the complement operator.\n// \n// ## License\n// \n// Copyright (c) 2011 Evan Wallace (http://madebyevan.com/), under the MIT license.\n\n// # class CSG\n\n// Holds a binary space partition tree representing a 3D solid. Two solids can\n// be combined using the `union()`, `subtract()`, and `intersect()` methods.\n\nexport default function CSG() {\n  this.polygons = [];\n};\n\n// Construct a CSG solid from a list of `CSG.Polygon` instances.\nCSG.fromPolygons = function(polygons) {\n  var csg = new CSG();\n  csg.polygons = polygons;\n  return csg;\n};\n\nCSG.prototype = {\n  clone: function() {\n    var csg = new CSG();\n    csg.polygons = this.polygons.map(function(p) { return p.clone(); });\n    return csg;\n  },\n\n  toPolygons: function() {\n    return this.polygons;\n  },\n\n  // Return a new CSG solid representing space in either this solid or in the\n  // solid `csg`. Neither this solid nor the solid `csg` are modified.\n  // \n  //     A.union(B)\n  // \n  //     +-------+            +-------+\n  //     |       |            |       |\n  //     |   A   |            |       |\n  //     |    +--+----+   =   |       +----+\n  //     +----+--+    |       +----+       |\n  //          |   B   |            |       |\n  //          |       |            |       |\n  //          +-------+            +-------+\n  // \n  union: function(csg) {\n    var a = new CSG.Node(this.clone().polygons);\n    var b = new CSG.Node(csg.clone().polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    return CSG.fromPolygons(a.allPolygons());\n  },\n\n  // Return a new CSG solid representing space in this solid but not in the\n  // solid `csg`. Neither this solid nor the solid `csg` are modified.\n  // \n  //     A.subtract(B)\n  // \n  //     +-------+            +-------+\n  //     |       |            |       |\n  //     |   A   |            |       |\n  //     |    +--+----+   =   |    +--+\n  //     +----+--+    |       +----+\n  //          |   B   |\n  //          |       |\n  //          +-------+\n  // \n  subtract: function(csg) {\n    var a = new CSG.Node(this.clone().polygons);\n    var b = new CSG.Node(csg.clone().polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG.fromPolygons(a.allPolygons());\n  },\n\n  // Return a new CSG solid representing space both this solid and in the\n  // solid `csg`. Neither this solid nor the solid `csg` are modified.\n  // \n  //     A.intersect(B)\n  // \n  //     +-------+\n  //     |       |\n  //     |   A   |\n  //     |    +--+----+   =   +--+\n  //     +----+--+    |       +--+\n  //          |   B   |\n  //          |       |\n  //          +-------+\n  // \n  intersect: function(csg) {\n    var a = new CSG.Node(this.clone().polygons);\n    var b = new CSG.Node(csg.clone().polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG.fromPolygons(a.allPolygons());\n  },\n\n  // Return a new CSG solid with solid and empty space switched. This solid is\n  // not modified.\n  inverse: function() {\n    var csg = this.clone();\n    csg.polygons.map(function(p) { p.flip(); });\n    return csg;\n  }\n};\n\n// // Construct an axis-aligned solid cuboid. Optional parameters are `center` and\n// // `radius`, which default to `[0, 0, 0]` and `[1, 1, 1]`. The radius can be\n// // specified using a single number or a list of three numbers, one for each axis.\n// // \n// // Example code:\n// // \n// //     var cube = CSG.cube({\n// //       center: [0, 0, 0],\n// //       radius: 1\n// //     });\n// CSG.cube = function(options) {\n//   options = options || {};\n//   var c = new CSG.Vector(options.center || [0, 0, 0]);\n//   var r = !options.radius ? [1, 1, 1] : options.radius.length ?\n//            options.radius : [options.radius, options.radius, options.radius];\n//   return CSG.fromPolygons([\n//     [[0, 4, 6, 2], [-1, 0, 0]],\n//     [[1, 3, 7, 5], [+1, 0, 0]],\n//     [[0, 1, 5, 4], [0, -1, 0]],\n//     [[2, 6, 7, 3], [0, +1, 0]],\n//     [[0, 2, 3, 1], [0, 0, -1]],\n//     [[4, 5, 7, 6], [0, 0, +1]]\n//   ].map(function(info) {\n//     return new CSG.Polygon(info[0].map(function(i) {\n//       var pos = new CSG.Vector(\n//         c.x + r[0] * (2 * !!(i & 1) - 1),\n//         c.y + r[1] * (2 * !!(i & 2) - 1),\n//         c.z + r[2] * (2 * !!(i & 4) - 1)\n//       );\n//       return new CSG.Vertex(pos, new CSG.Vector(info[1]));\n//     }));\n//   }));\n// };\n\n// // Construct a solid sphere. Optional parameters are `center`, `radius`,\n// // `slices`, and `stacks`, which default to `[0, 0, 0]`, `1`, `16`, and `8`.\n// // The `slices` and `stacks` parameters control the tessellation along the\n// // longitude and latitude directions.\n// // \n// // Example usage:\n// // \n// //     var sphere = CSG.sphere({\n// //       center: [0, 0, 0],\n// //       radius: 1,\n// //       slices: 16,\n// //       stacks: 8\n// //     });\n// CSG.sphere = function(options) {\n//   options = options || {};\n//   var c = new CSG.Vector(options.center || [0, 0, 0]);\n//   var r = options.radius || 1;\n//   var slices = options.slices || 16;\n//   var stacks = options.stacks || 8;\n//   var polygons = [], vertices;\n//   function vertex(theta, phi) {\n//     theta *= Math.PI * 2;\n//     phi *= Math.PI;\n//     var dir = new CSG.Vector(\n//       Math.cos(theta) * Math.sin(phi),\n//       Math.cos(phi),\n//       Math.sin(theta) * Math.sin(phi)\n//     );\n//     vertices.push(new CSG.Vertex(c.plus(dir.times(r)), dir));\n//   }\n//   for (var i = 0; i < slices; i++) {\n//     for (var j = 0; j < stacks; j++) {\n//       vertices = [];\n//       vertex(i / slices, j / stacks);\n//       if (j > 0) vertex((i + 1) / slices, j / stacks);\n//       if (j < stacks - 1) vertex((i + 1) / slices, (j + 1) / stacks);\n//       vertex(i / slices, (j + 1) / stacks);\n//       polygons.push(new CSG.Polygon(vertices));\n//     }\n//   }\n//   return CSG.fromPolygons(polygons);\n// };\n\n// // Construct a solid cylinder. Optional parameters are `start`, `end`,\n// // `radius`, and `slices`, which default to `[0, -1, 0]`, `[0, 1, 0]`, `1`, and\n// // `16`. The `slices` parameter controls the tessellation.\n// // \n// // Example usage:\n// // \n// //     var cylinder = CSG.cylinder({\n// //       start: [0, -1, 0],\n// //       end: [0, 1, 0],\n// //       radius: 1,\n// //       slices: 16\n// //     });\n// CSG.cylinder = function(options) {\n//   options = options || {};\n//   var s = new CSG.Vector(options.start || [0, -1, 0]);\n//   var e = new CSG.Vector(options.end || [0, 1, 0]);\n//   var ray = e.minus(s);\n//   var r = options.radius || 1;\n//   var slices = options.slices || 16;\n//   var axisZ = ray.unit(), isY = (Math.abs(axisZ.y) > 0.5);\n//   var axisX = new CSG.Vector(isY, !isY, 0).cross(axisZ).unit();\n//   var axisY = axisX.cross(axisZ).unit();\n//   var start = new CSG.Vertex(s, axisZ.negated());\n//   var end = new CSG.Vertex(e, axisZ.unit());\n//   var polygons = [];\n//   function point(stack, slice, normalBlend) {\n//     var angle = slice * Math.PI * 2;\n//     var out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));\n//     var pos = s.plus(ray.times(stack)).plus(out.times(r));\n//     var normal = out.times(1 - Math.abs(normalBlend)).plus(axisZ.times(normalBlend));\n//     return new CSG.Vertex(pos, normal);\n//   }\n//   for (var i = 0; i < slices; i++) {\n//     var t0 = i / slices, t1 = (i + 1) / slices;\n//     polygons.push(new CSG.Polygon([start, point(0, t0, -1), point(0, t1, -1)]));\n//     polygons.push(new CSG.Polygon([point(0, t1, 0), point(0, t0, 0), point(1, t0, 0), point(1, t1, 0)]));\n//     polygons.push(new CSG.Polygon([end, point(1, t1, 1), point(1, t0, 1)]));\n//   }\n//   return CSG.fromPolygons(polygons);\n// };\n\n// # class Vector\n\n// Represents a 3D vector.\n// \n// Example usage:\n// \n//     new CSG.Vector(1, 2, 3);\n//     new CSG.Vector([1, 2, 3]);\n//     new CSG.Vector({ x: 1, y: 2, z: 3 });\n\nCSG.Vector = function(x, y, z) {\n  if (arguments.length == 3) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  } else if ('x' in x) {\n    this.x = x.x;\n    this.y = x.y;\n    this.z = x.z;\n  } else {\n    this.x = x[0];\n    this.y = x[1];\n    this.z = x[2];\n  }\n};\n\nCSG.Vector.prototype = {\n  clone: function() {\n    return new CSG.Vector(this.x, this.y, this.z);\n  },\n\n  negated: function() {\n    return new CSG.Vector(-this.x, -this.y, -this.z);\n  },\n\n  plus: function(a) {\n    return new CSG.Vector(this.x + a.x, this.y + a.y, this.z + a.z);\n  },\n\n  minus: function(a) {\n    return new CSG.Vector(this.x - a.x, this.y - a.y, this.z - a.z);\n  },\n\n  times: function(a) {\n    return new CSG.Vector(this.x * a, this.y * a, this.z * a);\n  },\n\n  dividedBy: function(a) {\n    return new CSG.Vector(this.x / a, this.y / a, this.z / a);\n  },\n\n  dot: function(a) {\n    return this.x * a.x + this.y * a.y + this.z * a.z;\n  },\n\n  lerp: function(a, t) {\n    return this.plus(a.minus(this).times(t));\n  },\n\n  length: function() {\n    return Math.sqrt(this.dot(this));\n  },\n\n  unit: function() {\n    return this.dividedBy(this.length());\n  },\n\n  cross: function(a) {\n    return new CSG.Vector(\n      this.y * a.z - this.z * a.y,\n      this.z * a.x - this.x * a.z,\n      this.x * a.y - this.y * a.x\n    );\n  }\n};\n\n// # class Vertex\n\n// Represents a vertex of a polygon. Use your own vertex class instead of this\n// one to provide additional features like texture coordinates and vertex\n// colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n// `flip()`, and `interpolate()` methods that behave analogous to the ones\n// defined by `CSG.Vertex`. This class provides `normal` so convenience\n// functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`\n// is not used anywhere else.\n\nCSG.Vertex = function(pos, normal, uv, color) {\n  this.pos = new CSG.Vector(pos);\n  this.normal = new CSG.Vector(normal);\n  this.uv = uv && uv.clone();\n  this.color = color && new CSG.Vector(color);\n};\n\nCSG.Vertex.prototype = {\n  clone: function() {\n    return new CSG.Vertex(\n      this.pos.clone(), \n      this.normal.clone(),\n      this.uv && this.uv.clone(),\n      this.color && this.color.clone()\n    );\n  },\n\n  // Invert all orientation-specific data (e.g. vertex normal). Called when the\n  // orientation of a polygon is flipped.\n  flip: function() {\n    this.normal = this.normal.negated();\n  },\n\n  // Create a new vertex between this vertex and `other` by linearly\n  // interpolating all properties using a parameter of `t`. Subclasses should\n  // override this to interpolate additional properties.\n  interpolate: function(other, t) { \n    return new CSG.Vertex(\n      this.pos.lerp(other.pos, t),\n      this.normal.lerp(other.normal, t),\n      this.uv && other.uv && this.uv.clone().lerp(other.uv, t),\n      this.color && other.color && this.color.lerp(other.color, t),\n    );\n  }\n};\n\n// # class Plane\n\n// Represents a plane in 3D space.\n\nCSG.Plane = function(normal, w) {\n  this.normal = normal;\n  this.w = w;\n};\n\n// `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\n// point is on the plane.\nCSG.Plane.EPSILON = 1e-5;\n\nCSG.Plane.fromPoints = function(a, b, c) {\n  var n = b.minus(a).cross(c.minus(a)).unit();\n  return new CSG.Plane(n, n.dot(a));\n};\n\nCSG.Plane.prototype = {\n  clone: function() {\n    return new CSG.Plane(this.normal.clone(), this.w);\n  },\n\n  flip: function() {\n    this.normal = this.normal.negated();\n    this.w = -this.w;\n  },\n\n  // Split `polygon` by this plane if needed, then put the polygon or polygon\n  // fragments in the appropriate lists. Coplanar polygons go into either\n  // `coplanarFront` or `coplanarBack` depending on their orientation with\n  // respect to this plane. Polygons in front or in back of this plane go into\n  // either `front` or `back`.\n  splitPolygon: function(polygon, coplanarFront, coplanarBack, front, back) {\n    var COPLANAR = 0;\n    var FRONT = 1;\n    var BACK = 2;\n    var SPANNING = 3;\n\n    // Classify each point as well as the entire polygon into one of the above\n    // four classes.\n    var polygonType = 0;\n    var types = [];\n    for (var i = 0; i < polygon.vertices.length; i++) {\n      var t = this.normal.dot(polygon.vertices[i].pos) - this.w;\n      var type = (t < -CSG.Plane.EPSILON) ? BACK : (t > CSG.Plane.EPSILON) ? FRONT : COPLANAR;\n      polygonType |= type;\n      types.push(type);\n    }\n\n    // Put the polygon in the correct list, splitting it when necessary.\n    switch (polygonType) {\n      case COPLANAR:\n        (this.normal.dot(polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n        break;\n      case FRONT:\n        front.push(polygon);\n        break;\n      case BACK:\n        back.push(polygon);\n        break;\n      case SPANNING:\n        var f = [], b = [];\n        for (var i = 0; i < polygon.vertices.length; i++) {\n          var j = (i + 1) % polygon.vertices.length;\n          var ti = types[i], tj = types[j];\n          var vi = polygon.vertices[i], vj = polygon.vertices[j];\n          if (ti != BACK) f.push(vi);\n          if (ti != FRONT) b.push(ti != BACK ? vi.clone() : vi);\n          if ((ti | tj) == SPANNING) {\n            var t = (this.w - this.normal.dot(vi.pos)) / this.normal.dot(vj.pos.minus(vi.pos));\n            var v = vi.interpolate(vj, t);\n            f.push(v);\n            b.push(v.clone());\n          }\n        }\n        if (f.length >= 3) front.push(new CSG.Polygon(f, polygon.shared));\n        if (b.length >= 3) back.push(new CSG.Polygon(b, polygon.shared));\n        break;\n    }\n  }\n};\n\n// # class Polygon\n\n// Represents a convex polygon. The vertices used to initialize a polygon must\n// be coplanar and form a convex loop. They do not have to be `CSG.Vertex`\n// instances but they must behave similarly (duck typing can be used for\n// customization).\n// \n// Each convex polygon has a `shared` property, which is shared between all\n// polygons that are clones of each other or were split from the same polygon.\n// This can be used to define per-polygon properties (such as surface color).\n\nCSG.Polygon = function(vertices, shared) {\n  this.vertices = vertices;\n  this.shared = shared;\n  this.plane = CSG.Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n};\n\nCSG.Polygon.prototype = {\n  clone: function() {\n    var vertices = this.vertices.map(function(v) { return v.clone(); });\n    return new CSG.Polygon(vertices, this.shared);\n  },\n\n  flip: function() {\n    this.vertices.reverse().map(function(v) { v.flip(); });\n    this.plane.flip();\n  }\n};\n\n// # class Node\n\n// Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n// by picking a polygon to split along. That polygon (and all other coplanar\n// polygons) are added directly to that node and the other polygons are added to\n// the front and/or back subtrees. This is not a leafy BSP tree since there is\n// no distinction between internal and leaf nodes.\n\nCSG.Node = function(polygons) {\n  this.plane = null;\n  this.front = null;\n  this.back = null;\n  this.polygons = [];\n  if (polygons) this.build(polygons);\n};\n\nCSG.Node.prototype = {\n  clone: function() {\n    var node = new CSG.Node();\n    node.plane = this.plane && this.plane.clone();\n    node.front = this.front && this.front.clone();\n    node.back = this.back && this.back.clone();\n    node.polygons = this.polygons.map(function(p) { return p.clone(); });\n    return node;\n  },\n\n  // Convert solid space to empty space and empty space to solid space.\n  invert: function() {\n    for (var i = 0; i < this.polygons.length; i++) {\n      this.polygons[i].flip();\n    }\n    this.plane.flip();\n    if (this.front) this.front.invert();\n    if (this.back) this.back.invert();\n    var temp = this.front;\n    this.front = this.back;\n    this.back = temp;\n  },\n\n  // Recursively remove all polygons in `polygons` that are inside this BSP\n  // tree.\n  clipPolygons: function(polygons) {\n    if (!this.plane) return polygons.slice();\n    var front = [], back = [];\n    for (var i = 0; i < polygons.length; i++) {\n      this.plane.splitPolygon(polygons[i], front, back, front, back);\n    }\n    if (this.front) front = this.front.clipPolygons(front);\n    if (this.back) back = this.back.clipPolygons(back);\n    else back = [];\n    return front.concat(back);\n  },\n\n  // Remove all polygons in this BSP tree that are inside the other BSP tree\n  // `bsp`.\n  clipTo: function(bsp) {\n    this.polygons = bsp.clipPolygons(this.polygons);\n    if (this.front) this.front.clipTo(bsp);\n    if (this.back) this.back.clipTo(bsp);\n  },\n\n  // Return a list of all polygons in this BSP tree.\n  allPolygons: function() {\n    var polygons = this.polygons.slice();\n    if (this.front) polygons = polygons.concat(this.front.allPolygons());\n    if (this.back) polygons = polygons.concat(this.back.allPolygons());\n    return polygons;\n  },\n\n  // Build a BSP tree out of `polygons`. When called on an existing tree, the\n  // new polygons are filtered down to the bottom of the tree and become new\n  // nodes there. Each set of polygons is partitioned using the first polygon\n  // (no heuristic is used to pick a good split).\n  build: function(polygons) {\n    if (!polygons.length) return;\n    if (!this.plane) this.plane = polygons[0].plane.clone();\n    var front = [], back = [];\n    for (var i = 0; i < polygons.length; i++) {\n      this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n    }\n    if (front.length) {\n      if (!this.front) this.front = new CSG.Node();\n      this.front.build(front);\n    }\n    if (back.length) {\n      if (!this.back) this.back = new CSG.Node();\n      this.back.build(back);\n    }\n  }\n};\n","import CSG from \"../lib/csg.js\"\r\n\r\nexport default class Model {\r\n\r\n    constructor(THREE) {\r\n        this._THREE = THREE;\r\n        this._csg = null;\r\n    }\r\n\r\n    union(model) {\r\n        return csgToModel(this._THREE, this._csg.union(model._csg));\r\n    }\r\n\r\n    subtract(model) {\r\n        return csgToModel(this._THREE, this._csg.subtract(model._csg));\r\n    }\r\n\r\n    intersect(model) {\r\n        return csgToModel(this._THREE, this._csg.intersect(model._csg));\r\n    }\r\n\r\n    applyMatrix4(matrix) {\r\n        const mesh = this.build();\r\n        mesh.geometry.applyMatrix4(matrix);\r\n        return Model._fromMesh(this._THREE, mesh);\r\n    }\r\n\r\n    build() {\r\n        return csgToMesh(this._THREE, this._csg);\r\n    }\r\n\r\n    static _fromMesh(THREE, mesh) {\r\n        return meshToModel(THREE, mesh);\r\n    }\r\n\r\n}\r\n\r\nfunction csgToModel(THREE, csg) {\r\n    const m = new Model(THREE);\r\n    m._csg = csg;\r\n    return m;\r\n}\r\n\r\nfunction meshToModel(THREE, mesh) {\r\n    const m = new Model(THREE);\r\n    m._csg = CSG.fromPolygons(meshToPolygons(THREE, mesh));\r\n    return m;\r\n}\r\n\r\nfunction meshToPolygons(THREE, mesh) {\r\n\r\n    // Compute transformation matrix.\r\n    const clone = mesh.clone();\r\n    clone.updateMatrix();\r\n\r\n    // Snapshot material array.\r\n    if (Array.isArray(mesh.material)) {\r\n        clone.material = Array.from(mesh.material);\r\n    }\r\n\r\n    const polygons = [];\r\n    const geom = mesh.geometry;\r\n    const positions = geom.attributes.position.array;\r\n    const { normal, uv, color } = geom.attributes;\r\n    const hasNormalAttrib = normal !== undefined;\r\n    const normals = hasNormalAttrib ? normal.array : null;\r\n    const hasUvAttrib = uv !== undefined;\r\n    const uvs = hasUvAttrib ? uv.array : null;\r\n    const hasColorAttrib = color !== undefined;\r\n    const colors = hasColorAttrib ? color.array : null;\r\n    const indexAttrib = geom.index;\r\n    const elemCount = indexAttrib ? indexAttrib.count : positions.length / 3;\r\n    const shouldApplyMatrix = !clone.matrix.equals(new THREE.Matrix4());\r\n\r\n    for (let elemIdx = 0, $3i = 0, $3i3 = 0; elemIdx < elemCount; elemIdx += 3) {\r\n        const vertices = [];\r\n        for (let j = 0; j < 3; ++j) {\r\n            const i = (indexAttrib === null) ? elemIdx + j : indexAttrib.array[elemIdx + j];\r\n            $3i = 3 * i;\r\n            $3i3 = $3i + 3;\r\n            const position = shouldApplyMatrix\r\n                ? new THREE.Vector3().fromArray(positions, $3i).applyMatrix4(clone.matrix)\r\n                : positions.subarray($3i, $3i3);\r\n            const normal = hasNormalAttrib\r\n                ? normals.subarray($3i, $3i3)\r\n                : null;\r\n            const uv = hasUvAttrib\r\n                ? new THREE.Vector2().fromArray(uvs, 2 * i)\r\n                : null;\r\n            const color = hasColorAttrib\r\n                ? colors.subarray($3i, $3i3)\r\n                : null;\r\n            vertices.push(new CSG.Vertex(position, normal, uv, color));\r\n        }\r\n\r\n        let mI = 0;\r\n        for (const { start, count, materialIndex } of geom.groups) {\r\n            if (elemIdx >= start && elemIdx < start + count) {\r\n                mI = materialIndex;\r\n                break;\r\n            }\r\n        }\r\n\r\n        polygons.push(new CSG.Polygon(vertices, { m: clone.material, mI }));\r\n    }\r\n\r\n    return polygons;\r\n}\r\n\r\nfunction csgToMesh(THREE, csg) {\r\n    const polygons = csg.toPolygons();\r\n\r\n    // Group vertices by `Material`.\r\n\r\n    let vertsCount = 0;\r\n    const matMap = new Map();\r\n    for (const { vertices, shared: { m, mI } } of polygons) {\r\n        const mat = Array.isArray(m) ? m[mI] : m;\r\n        matMap.has(mat) || matMap.set(mat, []);\r\n        matMap.get(mat).push(vertices);\r\n        vertsCount += vertices.length;\r\n    }\r\n\r\n    // Alloc typedarrays to hold buffer attributes data.\r\n\r\n    const positions = new Float32Array(vertsCount * 3);\r\n    const normals = new Float32Array(vertsCount * 3);\r\n    const uvs = new Float32Array(vertsCount * 2);\r\n    const colors = new Float32Array(vertsCount * 3);\r\n\r\n    const materials = [];\r\n    const geom = new THREE.BufferGeometry();\r\n\r\n    let start = 0;\r\n    let count = 0; // how many indices a render group contains.\r\n    let positionsIdx = 0;\r\n    let normalsIdx = 0;\r\n    let uvsIdx = 0;\r\n    let colorsIdx = 0;\r\n    let materialIndex = 0;\r\n\r\n    let hasNormal = false, someHasNormal = false;\r\n    let hasUv = false, someHasUv = false;\r\n    let hasColor = false, someHasColor = false;\r\n\r\n    const indices = []; // holding actual data of element index buffer\r\n    let index = 0; // index number already used\r\n\r\n    for (const [material, vertsArray] of matMap.entries()) {\r\n\r\n        // Indice count. Since `vertesArray[n]` holds triangle fan verts \r\n        // if it has 4 verts, indice count should += 6 (2 tris).\r\n        count = 0;\r\n        for (const verts of vertsArray) {\r\n            \r\n            // Populate indices\r\n            for (let i = 1, I = verts.length - 1; i < I; ++i) {\r\n                indices.push(index, index + i, index + i + 1);\r\n            }\r\n            index += verts.length;\r\n            count += (verts.length - 2) * 3;\r\n\r\n            // Populate buffer attributes\r\n            for (const { pos, normal, uv, color } of verts) {\r\n                positions.set([pos.x, pos.y, pos.z], positionsIdx);\r\n                positionsIdx += 3;\r\n\r\n                someHasNormal |= (hasNormal = normal !== null);\r\n                normals.set(hasNormal ? [normal.x, normal.y, normal.z] : [0, 0, 0], normalsIdx);\r\n                normalsIdx += 3;\r\n\r\n                someHasUv |= (hasUv = uv !== null);\r\n                uvs.set(hasUv ? uv.toArray() : [0, 0], uvsIdx);\r\n                uvsIdx += 2;\r\n\r\n                someHasColor |= (hasColor = color !== null);\r\n                colors.set(hasColor ? [color.x, color.y, color.z] : [0, 0, 0], colorsIdx);\r\n                colorsIdx += 3;\r\n            }\r\n        }\r\n\r\n        materials.push(material);\r\n        geom.addGroup(start, count, materialIndex);\r\n        start += count;\r\n        materialIndex += 1;\r\n    }\r\n\r\n    // Set element index buffer.\r\n\r\n    geom.index = (index > 65536)\r\n        ? new THREE.Uint32BufferAttribute(indices, 1)\r\n        : new THREE.Uint16BufferAttribute(indices, 1);\r\n\r\n    // Pluck buffer attributes.\r\n\r\n    geom.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\r\n\r\n    if (someHasNormal) {\r\n        geom.setAttribute(\"normal\", new THREE.BufferAttribute(normals, 3));\r\n    }\r\n\r\n    if (someHasUv) {\r\n        geom.setAttribute(\"uv\", new THREE.BufferAttribute(uvs, 2));\r\n    }\r\n\r\n    if (someHasColor) {\r\n        geom.setAttribute(\"color\", new THREE.BufferAttribute(colors, 3));\r\n    }\r\n\r\n    return new THREE.Mesh(geom, materials);\r\n}\r\n","import Model from \"./Model.js\"\r\n\r\nexport default class Modeller {\r\n\r\n    constructor(THREE) {\r\n        this._THREE = THREE;\r\n    }\r\n\r\n    model(mesh) {\r\n        return Model._fromMesh(this._THREE, mesh);\r\n    }\r\n\r\n}"],"names":["CSG","this","polygons","fromPolygons","csg","prototype","clone","map","p","toPolygons","union","a","Node","b","clipTo","invert","build","allPolygons","subtract","intersect","inverse","flip","Vector","x","y","z","arguments","length","negated","plus","minus","times","dividedBy","dot","lerp","t","Math","sqrt","unit","cross","Vertex","pos","normal","uv","color","interpolate","other","Plane","w","EPSILON","fromPoints","c","n","splitPolygon","polygon","coplanarFront","coplanarBack","front","back","polygonType","types","i","vertices","type","push","plane","f","j","ti","tj","vi","vj","v","Polygon","shared","reverse","node","temp","clipPolygons","slice","concat","bsp","Model","[object Object]","THREE","_THREE","_csg","model","csgToModel","matrix","mesh","geometry","applyMatrix4","_fromMesh","vertsCount","matMap","Map","m","mI","mat","Array","isArray","has","set","get","positions","Float32Array","normals","uvs","colors","materials","geom","BufferGeometry","start","count","positionsIdx","normalsIdx","uvsIdx","colorsIdx","materialIndex","hasNormal","someHasNormal","hasUv","someHasUv","hasColor","someHasColor","indices","index","material","vertsArray","entries","verts","I","toArray","addGroup","Uint32BufferAttribute","Uint16BufferAttribute","setAttribute","BufferAttribute","Mesh","csgToMesh","updateMatrix","from","attributes","position","array","hasNormalAttrib","undefined","hasUvAttrib","hasColorAttrib","indexAttrib","elemCount","shouldApplyMatrix","equals","Matrix4","elemIdx","$3i","$3i3","Vector3","fromArray","subarray","Vector2","groups","meshToPolygons","meshToModel"],"mappings":"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"}